# 详细：LUT（查表）加速 与 ROI（局部检测）

---

## 1. LUT（查找表）加速 — 原理与变种

### 1.1 基本原理
- **思想**：把重复且代价高的像素级运算（例如颜色通道判断、Gamma 校正、简单映射）**预先计算**成数组（表），运行时对每个像素直接查表替代计算。
- **时间复杂度**：从每像素 O(cost_of_calc) 变为 O(1) 的内存访问（通常可被 SIMD 加速）。
- **适用场景**：像素级独立操作（无邻域依赖），例如单通道阈值、通道映射、伽马/对比度查表、通道范围判断等。

### 1.2 常见 LUT 类型
1. **单通道一维 LUT（最常用）**
   - 大小：256（8-bit）项。
   - 用途：灰度阈值、单通道映射（比如 A 通道是否在目标区间 → 0/255）。
   - 优点：内存小、非常快，直接调用 `cv::LUT()`。

2. **双通道/三通道组合 LUT（降采样的多维 LUT）**
   - 理想三维 LUT（256³）太大（~16.7M 项），但可以通过**量化**降到例如 32³（32K）或 64³（262K）项。
   - 用法：对 RGB 或 Lab 三通道做近似映射（更精确的颜色分类）。
   - 权衡：更大内存、但仍比每像素复杂运算快。

3. **逻辑/位掩码 LUT**
   - 为某个通道预先产出 0/1 掩码：`lut_A[256]`、`lut_B[256]`，然后 `bitwise_and` 合并。
   - 极高效率（能充分利用 CPU 矢量化）。

4. **分段/区域 LUT**
   - 只对某些通道值范围建立表（例如 A ∈ [100,160]），其余值直接判为 0。
   - 适合目标颜色集中于窄带情况。

5. **GPU/着色器 LUT**
   - 在 GPU 上通过纹理查表（3D texture）实现，高速且适合高分辨率；但实现复杂度与依赖更多硬件。

### 1.3 在 OpenCV 中应用 LUT
- `cv::LUT(src, lut, dst)`：对每个像素的每个通道使用一维 LUT（如果 `src` 多通道并且 `lut` 是 256×1，OpenCV 会对每通道应用同一个 lut）。
- 常用技巧：先拆通道（`split()`），对每个通道单独 `cv::LUT`，再逻辑组合。

#### 示例：为 Lab 的 A、B 通道建立掩码 LUT 并组合
```cpp
// 构建 LUT（A通道偏红区）
cv::Mat lutA(1, 256, CV_8UC1);
for (int i = 0; i < 256; ++i) {
    lutA.at<uchar>(i) = (i >= 130 && i <= 145) ? 255 : 0;
}
// B 通道偏黄区
cv::Mat lutB(1, 256, CV_8UC1);
for (int i = 0; i < 256; ++i) {
    lutB.at<uchar>(i) = (i >= 132 && i <= 155) ? 255 : 0;
}

// 应用
cv::Mat A_mask, B_mask;
cv::LUT(A_channel, lutA, A_mask);
cv::LUT(B_channel, lutB, B_mask);

// 组合
cv::Mat woodMask;
cv::bitwise_and(A_mask, B_mask, woodMask);
